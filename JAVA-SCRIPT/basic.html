<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>BasicJS â€” Complete Fundamentals (Interactive)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: #0b1220;
            color: #e6eef8;
            font-family: Inter, Segoe UI, system-ui;
        }

        h1,
        h2 {
            color: #60a5fa;
        }

        code,
        pre {
            background: #071029;
            padding: .15rem .4rem;
            border-radius: 6px;
            display: inline-block;
        }

        .section {
            border: 1px solid #15304a;
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
        }

        .small {
            font-size: .95rem;
            color: #cbd5e1;
        }

        .muted {
            color: #94a3b8;
        }

        .btn {
            background: #0369a1;
            color: white;
            padding: .45rem .8rem;
            border-radius: 8px;
            cursor: pointer;
            border: none
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .code-block {
            background: #041227;
            padding: 8px;
            border-radius: 8px;
            overflow: auto;
        }
    </style>
</head>

<body class="p-6">
    <h1 class="text-3xl mb-2">ðŸ“˜ BasicJS â€” Complete Fundamentals (Interactive TL;DR)</h1>
    <p class="muted mb-6">Detailed examples & explanations for variables, types, operators, control flow, loops,
        functions, objects, arrays, ES6+ features, hoisting, closures, DOM & events, plus interactive snippets.</p>

    <div id="output"></div>

    <script>
        // Utility to safely escape HTML in text
        function esc(s) {
            if (s === undefined) return "";
            return String(s)
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');
        }

        const output = document.getElementById('output');
        function print(title, example, explanation, resultHTML) {
            const exampleEsc = esc(example).replaceAll('\\n', '<br>');
            const explanationEsc = esc(explanation).replaceAll('\\n', '<br>');
            output.innerHTML += `
        <div class="section">
          <h2 class="text-2xl mb-1">${esc(title)}</h2>
          <div class="small mb-2"><strong>Example:</strong>
            <div class="code-block mt-1"><pre><code>${exampleEsc}</code></pre></div>
          </div>
          <p class="small mb-2"><strong>Explanation:</strong> ${explanationEsc}</p>
          <p class="small"><strong>Result:</strong> ${resultHTML}</p>
        </div>`;
        }

        // ---------- VARIABLES ----------
        // var / let / const, redeclare, reassign, scope
        (function () {
            // examples & demonstration
            let example = "var x = 1; function f(){ var x = 2; console.log(x) } // function-scoped\n" +
                "let y = 1; if(true){ let y = 2; console.log(y) } // block-scoped\n" +
                "const z = 3; // cannot reassign";
            let explanation = "var = function-scoped and can be redeclared; let = block-scoped, reassignable; const = block-scoped, cannot reassign (but objects assigned to const can be mutated). Use let/const in modern code.";
            var x = "global-var";
            let y = "global-let";
            const z = "global-const";
            let result = `<code>var x = "${x}"</code>, <code>let y = "${y}"</code>, <code>const z = "${z}"</code>`;
            print("Variables â€” var / let / const (scope & reassignment)", example, explanation, result);
        })();

        // ---------- DATA TYPES ----------
        (function () {
            let example = [
                "// Primitives:",
                "Number, String, Boolean, Null, Undefined, Symbol, BigInt",
                "// Reference:",
                "Object, Array, Function, Date, Map, Set"
            ].join("\n");
            let explanation = "Primitives hold values directly. Reference types (objects, arrays) hold references. typeof distinguishes primitives (except null is 'object'). Symbol and BigInt are newer primitives.";
            let num = 42, str = "hi", bool = true, n = null, undef = undefined, sym = Symbol('s'), big = 123n;
            let obj = { a: 1 }, arr = [1, 2], fn = function () { }, map = new Map(), set = new Set();
            let result = esc(`typeof num=${typeof num}, str=${typeof str}, bool=${typeof bool}, null=${typeof n}, undefined=${typeof undef}, symbol=${typeof sym}, bigint=${typeof big}`) +
                "<br>" + esc(`typeof obj=${typeof obj}, Array.isArray(arr)=${Array.isArray(arr)}, typeof fn=${typeof fn}`);
            print("Data Types â€” primitives vs reference", example, explanation, result);
        })();

        // ---------- TYPE CONVERSION ----------
        (function () {
            let example = [
                "Implicit: '5' + 2 -> '52' (string concatenation)",
                "Explicit: Number('5') -> 5, String(5) -> '5', Boolean(0) -> false"
            ].join("\n");
            let explanation = "JS auto-converts types (coercion). Use explicit conversions to be safe.";
            let r = `'5' + 2 => ${'5' + 2}, Number('5') => ${Number('5')}, + '5' => ${+'5'}, Boolean(0) => ${Boolean(0)}`;
            print("Type Conversion â€” implicit vs explicit", example, explanation, r);
        })();

        // ---------- OPERATORS (detailed) ----------
        (function () {
            // arithmetic
            let example = [
                "Arithmetic: + - * / % (mod) ** (pow) ++ --",
                "Comparison: == === != !== > >= < <=",
                "Logical: && || !",
                "Bitwise: & | ^ ~ << >> >>>",
                "Assignment: = += -= *= /= %= **=",
                "Ternary: condition ? a : b",
                "Nullish: ??  Optional chaining: ?."
            ].join("\n");
            let explanation = "Operators manipulate or compare values. Use === to avoid type-coercion surprises; ?? differs from || because it only treats null/undefined as 'nullish'. Optional chaining prevents errors when traversing nested objects.";
            let a = 7, b = 2;
            let result = esc(`a+b=${a + b}, a-b=${a - b}, a*b=${a * b}, a/b=${a / b}, a% b=${a % b}, a**b=${a ** b}`) +
                "<br>" + esc(`a== '7' => ${a == '7'}, a === '7' => ${a === '7'}`) +
                "<br>" + esc(`true && false => ${true && false}, true || false => ${true || false}, !true => ${!true}`) +
                "<br>" + esc(`null ?? 'x' => ${null ?? 'x'}, '' || 'x' => ${'' || 'x'}`) +
                "<br>" + esc(`Optional chaining: ({}).a?.b => ${(({}).a?.b)}`);
            print("Operators â€” arithmetic, comparison, logical, bitwise, assignment, ternary, nullish, optional chaining", example, explanation, result);
        })();

        // ---------- CONTROL FLOW ----------
        (function () {
            let example = [
                "if (cond) {} else if (cond2) {} else {}",
                "switch(value) { case 'a': ...; break; default: ... }",
                "ternary: cond ? a : b"
            ].join("\n");
            let explanation = "Use if/else for conditional branching. Use switch for many exact value branches. Ternary is short inline if/else for simple expressions.";
            let grade = 82;
            let res = (grade > 90) ? 'A+' : (grade > 75) ? 'A' : (grade > 60) ? 'B' : 'C';
            print("Control Flow â€” if / switch / ternary", example, explanation, `grade ${grade} -> ${res}`);
        })();

        // ---------- LOOPS ----------
        (function () {
            let example = [
                "for (let i=0;i<3;i++) {}",
                "while (cond) {}",
                "do { } while (cond);",
                "for (let key in obj) {} // keys",
                "for (let val of arr) {} // values"
            ].join("\n");
            let explanation = "Use for when count known, while when condition-based. for..in iterates object keys, for..of iterates iterable values (arrays, strings).";
            let forRes = [];
            for (let i = 0; i < 3; i++) forRes.push(i);
            let arr = ['a', 'b', 'c'];
            let forOf = [];
            for (let v of arr) forOf.push(v);
            let forInRes = [];
            const o = { x: 1, y: 2 };
            for (let k in o) forInRes.push(k);
            let result = `for -> [${forRes}], for...of -> [${forOf}], for...in -> [${forInRes}]`;
            print("Loops â€” for / while / do-while / for...in / for...of", example, explanation, result);
        })();

        // ---------- FUNCTIONS (many types) ----------
        (function () {
            let example = [
                "Function declaration: function sum(a,b){ return a+b }",
                "Function expression: const sum = function(a,b) { return a+b }",
                "Arrow: const mul = (a,b) => a*b",
                "IIFE: (function(){ console.log('run') })()",
                "Higher-order: function hof(fn){ return function(){ fn() } }",
                "Async function: async function f(){ await Promise.resolve(1) }"
            ].join("\n");
            let explanation = "Functions are first-class (can be passed around). Arrow functions: shorter + lexical this. IIFE runs immediately. Higher-order functions take or return functions. Async/await helps with async flow.";
            function dec(a, b) { return a + b; }
            const expr = function (a, b) { return a - b; };
            const arrow = (a, b) => a * b;
            const iifeVal = (function () { return 'iife-run' })();
            function hof(fn) { return function (...args) { return fn(...args) } }
            const doubled = [1, 2, 3].map(x => x * 2);
            let result = `dec(2,3)=${dec(2, 3)}, expr(5,2)=${expr(5, 2)}, arrow(2,3)=${arrow(2, 3)}, iife=${iifeVal}, hof-> double [${doubled}]`;
            print("Functions â€” declaration, expression, arrow, IIFE, higher-order, async", example, explanation, result);

            // Async demo printed with promise resolution
            (async function demoAsync() {
                async function waitAdd(a, b) { return a + b }
                let pr = waitAdd(2, 3);
                let resolved = await pr;
                output.innerHTML += `<div class="section small"><strong>Async example result:</strong> waitAdd(2,3) => ${resolved}</div>`;
            })();
        })();

        // ---------- OBJECTS & PROTOTYPES & CLASS ----------
        (function () {
            let example = [
                "Object literal: const o = { name:'A', age:10 }",
                "Access: o.name, o['name']",
                "Prototype: function C(){}; C.prototype.foo = ()=>{}",
                "Class: class C { constructor(){ } method(){} }"
            ].join("\n");
            let explanation = "Objects store keyed collections. JS uses prototype-based inheritance. class is syntactic sugar over prototypes.";
            const person = { name: 'Chetan', age: 20, greet() { return `Hi ${this.name}` } };
            // prototype chain example
            function Person(n) { this.name = n }
            Person.prototype.say = function () { return 'hello ' + this.name }
            const p = new Person('X');
            // class
            class User { constructor(n) { this.name = n } greet() { return `Hey ${this.name}` } }
            const u = new User('Y');
            let result = esc(`${person.greet()}, prototype.say -> ${p.say()}, class.greet -> ${u.greet()}`);
            print("Objects, prototypes & class", example, explanation, result);
        })();

        // ---------- ARRAYS (methods & iterators) ----------
        (function () {
            let example = [
                "Creation: [] or new Array()",
                "Mutating: push, pop, shift, unshift, splice",
                "Non-mutating: map, filter, reduce, slice, concat",
                "Iterators: forEach, entries(), keys(), values()"
            ].join("\n");
            let explanation = "Arrays are ordered lists. Prefer non-mutating methods when possible (immutability). Use map/filter/reduce for functional transforms.";
            let arr = [1, 2, 3, 4];
            let mapped = arr.map(x => x * 2);
            let filtered = arr.filter(x => x % 2 === 0);
            let reduced = arr.reduce((s, x) => s + x, 0);
            arr.push(5); // mutate
            let result = `mapped [${mapped}], filtered [${filtered}], reduced=${reduced}, after push arr=[${arr}]`;
            print("Arrays â€” creation, mutating & non-mutating methods, iterators", example, explanation, result);
        })();

        // ---------- MAP / SET / WEAKMAP / WEAKSET ----------
        (function () {
            let example = [
                "Map: key-value with arbitrary key types; new Map()",
                "Set: unique values; new Set()",
                "WeakMap/WeakSet: keys are weakly held, help GC (only objects allowed)"
            ].join("\n");
            let explanation = "Use Map when keys are not strings or you need insertion order. Use Set for unique collections. WeakMap/WeakSet are for memory-sensitive caches.";
            let m = new Map(); m.set({}, 'objKey'); m.set('k', 'v');
            let s = new Set([1, 2, 2, 3]);
            let result = `Map size=${m.size}, Set unique values -> [${[...s]}]`;
            print("Map / Set / WeakMap / WeakSet", example, explanation, result);
        })();

        // ---------- TEMPLATE LITERALS ----------
        (function () {
            let example = [
                "Backticks: `Hello ${name}`",
                "Multi-line strings: `line1\\nline2`",
                "Tagged templates: tag`text ${val}`"
            ].join("\n");
            let explanation = "Template literals ease interpolation and multi-line strings. Tagged templates let you customize processing of template literals.";
            let name = 'Chetan';
            let result = esc(`Hello ${name}! (multi-line supported)`);
            print("Template Literals â€” interpolation & multi-line", example, explanation, result);
        })();

        // ---------- DESTRUCTURING & SPREAD / REST ----------
        (function () {
            let example = [
                "Array destructuring: const [a,b] = [1,2]",
                "Object destructuring: const {x,y} = obj",
                "Spread: [...arr], {...obj}",
                "Rest: function(...args) {}"
            ].join("\n");
            let explanation = "Destructuring extracts values from arrays/objects. Spread expands iterables. Rest collects arguments into array.";
            const arr = [1, 2, 3];
            const [first, ...rest] = arr;
            const o = { x: 1, y: 2, z: 3 };
            const { x, ...others } = o;
            const result = `first=${first}, rest=[${rest}], x=${x}, others=${JSON.stringify(others)}`;
            print("Destructuring, Spread & Rest", example, explanation, result);
        })();

        // ---------- PROMISES, ASYNC/AWAIT ----------
        (function () {
            let example = [
                "Promise: new Promise((resolve,reject)=>{ ... })",
                "Then/catch: p.then(...).catch(...)",
                "Async/await: async function f(){ await p }"
            ].join("\n");
            let explanation = "Promises represent future values. Async/await is syntactic sugar over promises. Always handle errors (try/catch).";
            // demo small promise
            function wait(ms, val) { return new Promise(res => setTimeout(() => res(val), ms)) }
            wait(10, 7).then(v => {
                output.innerHTML += `<div class="section small"><strong>Promise demo:</strong> wait(10,'7') resolved -> ${v}</div>`;
            });
            print("Promises & Async/Await", example, explanation, "See live small demo above (resolved promise). Use try/catch for await.");
        })();

        // ---------- HOISTING & TEMPORAL DEAD ZONE ----------
        (function () {
            let example = [
                "Hoisting: declarations are moved to top. var gets hoisted & initialized as undefined.",
                "let/const are hoisted but in TDZ â€” cannot access before declaration."
            ].join("\n");
            let explanation = "Avoid relying on hoisting. Prefer declaring variables at top of block or before use.";
            let hoistDemo;
            try {
                hoistDemo = esc(String(xVar)); // reference error if not defined â€” but xVar defined below with var
            } catch (e) {
                hoistDemo = "ReferenceError before declaration for let/const; var is undefined if accessed before assignment (not ReferenceError).";
            }
            var xVar = "i am var";
            print("Hoisting & TDZ", example, explanation, `var xVar declared later -> '${xVar}'. Note: let/const would throw if accessed earlier (TDZ).`);
        })();

        // ---------- CLOSURES & SCOPE CHAIN ----------
        (function () {
            let example = [
                "Closure: function inner() uses outer's variables which persist.",
                "Example: function makeAdder(x){ return (y) => x+y }"
            ].join("\n");
            let explanation = "Closures capture variables from outer scopes and keep them alive. Useful for encapsulation and factory functions.";
            function makeAdder(x) { return function (y) { return x + y } }
            const add5 = makeAdder(5);
            let result = `add5(3) => ${add5(3)} (closure captured x=5)`;
            print("Closures & Scope Chain", example, explanation, result);
        })();

        // ---------- STRICT MODE ----------
        (function () {
            let example = [
                "'use strict'; at top of file or function forces stricter parsing and error throwing (e.g., assignment to undeclared variable throws)."
            ].join("\n");
            let explanation = "Use strict mode to avoid silent errors and to enable safer JavaScript subset. Modules are strict by default.";
            print("Strict Mode", example, explanation, "Prefer 'use strict' in scripts or use ES modules which are strict by default.");
        })();

        // ---------- MODULES (brief) ----------
        (function () {
            let example = [
                "// Named export: export function f() {}",
                "// Import: import { f } from './file.js'",
                "// Default: export default class {}"
            ].join("\n");
            let explanation = "Use ES modules (import/export) for modular code. Node.js supports ES modules with .mjs or package.json config.";
            print("Modules â€” import / export (ES Modules)", example, explanation, "Use modules to split code; bundlers & Node handle module resolution.");
        })();

        // ---------- DOM & EVENTS (interactive) ----------
        (function () {
            let example = [
                "document.getElementById('id'), document.querySelector('.cls')",
                "addEventListener('click', fn) preferred over inline handlers",
                "Example below shows button click incrementing a counter (live)."
            ].join("\n");
            let explanation = "DOM API manipulates HTML. Use event listeners for interactions. Avoid heavy DOM manipulation in tight loops.";
            // create interactive area
            const id = 'dom-demo-' + Math.random().toString(36).slice(2, 8);
            output.innerHTML += `
        <div class="section">
          <h2 class="text-2xl mb-1">DOM & Events â€” interactive demo</h2>
          <div class="small mb-2">
            <div class="code-block"><pre><code>const btn = document.getElementById('${id}-btn'); btn.addEventListener('click', ()=>{++count; update();})</code></pre></div>
          </div>
          <p class="small mb-2">Click the button to increment the counter.</p>
          <div class="muted">Counter: <span id="${id}-count">0</span></div>
          <div class="mt-2"><button class="btn" id="${id}-btn">Click me</button></div>
        </div>
      `;
            let count = 0;
            function update() { document.getElementById(id + '-count').innerText = count; }
            document.addEventListener('click', function onDoc(e) {
                // delegate when DOM nodes are ready
                const btn = document.getElementById(id + '-btn');
                if (btn) {
                    btn.addEventListener('click', () => { count++; update(); });
                    document.removeEventListener('click', onDoc);
                }
            });
            print("DOM & Events (summary)", example, explanation, `Interactive demo created (button id: ${id}-btn)`);
        })();

        // ---------- ERROR HANDLING ----------
        (function () {
            let example = [
                "try { ... } catch (err) { ... } finally { ... }",
                "throw new Error('oops')"
            ].join("\n");
            let explanation = "Use try/catch to handle synchronous errors. For promises, use .catch() or try/catch with await.";
            try {
                // demo
                throw new Error("demo error");
            } catch (err) {
                var caught = err.message;
            }
            print("Error Handling â€” try / catch / finally", example, explanation, `Caught error message: ${caught}`);
        })();

        // ---------- PERFORMANCE & BEST PRACTICES (brief) ----------
        (function () {
            let example = [
                "Prefer let/const over var",
                "Avoid polluting globals",
                "Use debouncing/throttling for frequent events",
                "Prefer non-mutating array methods for immutability when possible"
            ].join("\n");
            let explanation = "Keep code modular, readable, and avoid premature optimization. Use browser devtools & profiler when needed.";
            print("Performance & Best Practices (summary)", example, explanation, "Readability + correctness > micro-optimizations; profile before optimizing.");
        })();

        // ---------- SUMMARY (compact cheat-sheet) ----------
        (function () {
            let example = [
                "Cheat-sheet: var/let/const | primitives/reference | + - * / | === vs == | && || ! | map/filter/reduce | async/await | class/prototype | closures | modules"
            ].join("\n");
            let explanation = "This summary is a quick lookup for core JS concepts; use the sections above for examples.";
            })();

        
    </script>
</body>

</html>